package sm2

import (
	"bytes"

	"crypto/sm3"
)

//Za=SM3Hash(ENTLA||ID||a||b||Gx||Gy||Xa||Ya)
//ENTLA:用户ID的bit位长度
//ID: 用户ID
//a: 椭圆曲线公钥密码算法推荐曲线参数a
//b: 椭圆曲线公钥密码算法推荐曲线参数b
//Gx: 椭圆曲线公钥密码算法推荐曲线参数Gx
//Gy: 椭圆曲线公钥密码算法推荐曲线参数Gy
//Xa: 公钥X
//Ya: 公钥Y
func CalZa(pub *PublicKey) []byte {
	var (
		ENTLA = []byte{0, 0x80}
		ID    = []byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}
		a     = []byte{0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC}
		b     = []byte{0x28, 0xE9, 0xFA, 0x9E, 0x9D, 0x9F, 0x5E, 0x34, 0x4D, 0x5A, 0x9E, 0x4B, 0xCF, 0x65, 0x09, 0xA7, 0xF3, 0x97, 0x89, 0xF5, 0x15, 0xAB, 0x8F, 0x92, 0xDD, 0xBC, 0xBD, 0x41, 0x4D, 0x94, 0x0E, 0x93}
		Gx    = []byte{0x32, 0xC4, 0xAE, 0x2C, 0x1F, 0x19, 0x81, 0x19, 0x5F, 0x99, 0x04, 0x46, 0x6A, 0x39, 0xC9, 0x94, 0x8F, 0xE3, 0x0B, 0xBF, 0xF2, 0x66, 0x0B, 0xE1, 0x71, 0x5A, 0x45, 0x89, 0x33, 0x4C, 0x74, 0xC7}
		Gy    = []byte{0xBC, 0x37, 0x36, 0xA2, 0xF4, 0xF6, 0x77, 0x9C, 0x59, 0xBD, 0xCE, 0xE3, 0x6B, 0x69, 0x21, 0x53, 0xD0, 0xA9, 0x87, 0x7C, 0xC6, 0x2A, 0x47, 0x40, 0x02, 0xDF, 0x32, 0xE5, 0x21, 0x39, 0xF0, 0xA0}
	)
	var buffer bytes.Buffer
	buffer.Write(ENTLA)
	buffer.Write(ID)
	buffer.Write(a)
	buffer.Write(b)
	buffer.Write(Gx)
	buffer.Write(Gy)
	buffer.Write(pub.X.Bytes())
	buffer.Write(pub.Y.Bytes())
	in := buffer.Bytes()

	h := sm3.New()
	h.Write(in)
	digest := h.Sum(nil)

	return digest
}

//M'=Za||M
//e=SM3Hash(M')
func HashMsgZa(msg []byte, pub *PublicKey) []byte {
	za := CalZa(pub)

	var buffer bytes.Buffer
	buffer.Write(za)
	buffer.Write(msg)
	m := buffer.Bytes()

	h := sm3.New()
	h.Write(m)
	digest := h.Sum(nil)

	return digest
}
